# P1PP – C Preprocessor (Practice 1)

> **Course:** Compilers  
> **Practice:** P1 – Preprocessor (P1PP)  
> **This README is a living internal design document for the team.**

---

## 1. Project Goal

The goal of this project is to design and implement a **modular C preprocessor (P1PP)** as the first stage of a compiler.

This project corresponds to **Practice 1 (P1PP)** of the Compilers course.  
Later practices will extend this project toward lexical analysis (P2), parsing, and further compiler phases.

The focus of P1 is:
- correct preprocessing behavior
- clear internal architecture
- well-defined data structures
- modular responsibilities

This README is **not a user manual**.  
It is an **internal working specification** for the development team.

---

## 2. Input and Output

### Input
- A C source file (`.c` or `.h`)
- Command-line options:
  - `-c` : remove comments (**default if no flags are provided**)
  - `-d` : process directives
  - `-all` : equivalent to `-c -d`
  - `-help` : print usage and exit

### Output
- A new source file with preprocessing applied
- Output filename is generated by inserting `_pp` before the extension:
  - `file.c` → `file_pp.c`
  - `file.h` → `file_pp.h`

---

## 3. Repository Structure

The project is organized into independent modules under `src/`.

```text
src/
main.c                // program entry point (wrapper only)

cli/                  // command-line parsing
  cli.h
  cli.c

pp_core/              // preprocessing engine (single pass)
  pp_core.h
  pp_core.c
  pp_context.h

buffer/               // dynamic text buffer utilities
  buffer.h
  buffer.c

io/                   // file input/output
  io.h
  io.c

comments/             // comment removal
  comments.h
  comments.c

directives/           // #include, #define, #ifdef/#endif
  directives.h
  directives.c

macros/               // macro table + expansion
  macros.h
  macros.c

tokens/               // lightweight tokenizer (P1 helper)
  tokens.h
  tokens.c

errors/               // error reporting
  errors.h
  errors.c

spec/                 // constants and shared definitions
  pp_spec.h
```
---

## 4. High-Level Architecture

### Design principles
- `main.c` is a **wrapper only**
- **PP_CORE** owns the preprocessing pass and line iteration
- Other modules are **services** called by PP_CORE
- Only IO accesses the filesystem
- Only PP_CORE scans the input text line-by-line

This avoids duplicated logic and keeps line counting consistent.

---

## 5. Preprocessing Pipeline (Passes)

### Pass 0 — Setup
- CLI parses command-line arguments into `cli_options_t`
- Preprocessing context (`pp_context_t`), macro table, conditional (#ifdef) stack and error counter are initialized

### Pass 1 — Preprocessing (single main pass)
- PP_CORE scans the input **line-by-line** 
- For each line:
   1. PP_CORE calls comments_process_line(raw input) from Comments Module and comments are removed (if enabled)
   2. After comment removal, PP_CORE checks:
      whether the first non-whitespace character is # (if directive handling enabled)
      - If YES:
          the line is classified as a directive line and PP_CORE calls directives_process_line(input after comments removed)

        Inside Directives:
          1. the line is tokenized using the Tokens helper (store type, lenght, line for error handling)
          2. directive syntax is validated (#include, #define, #ifdef, #endif)
          3. macro table and conditional stack are updated
          4. errors are reported via the Errors module

      - If NO:
          the line is classified as a normal code line and processing continues to macro expansion (if enabled)


  3. For normal (non-directive) lines only:
       PP_CORE calls macros_expand_line() (if enabled)

     Inside Macros:
       1. the line is tokenized using the Tokens helper
       2. macro expansion

  5. Finally the processed line is appended to the output buffer and processing continues with the next input line
      
### Pass 2 — Write
- IO writes the output buffer to the `_pp` output file

> The design uses **one main pass over the input**, as required.

---

## 6. Who Reads the Lines?

**PP_CORE is the only module that reads the input line-by-line.**

Rationale:
- single point of control for the pass
- consistent line numbering
- no duplicated scans across modules

Other modules operate **only on one line at a time** and never iterate over the full input.

---

## 7. Core Data Structures

### CLI options
```c
typedef struct {
    int do_comments;    // -c
    int do_directives;  // -d
    int do_help;        // -help
} cli_options_t;
```

### Macro table (required by #define and #ifdef)
```c
typedef struct {
    char *name;
    char *value;
} macro_t;

typedef struct {
    macro_t *items;
    int size;
    int capacity;
} macro_table_t;
```
### Preprocessing context
```c
typedef struct {
    cli_options_t opt;

    const char *current_file;
    int current_line;

    macro_table_t macros;

    int if_stack[PP_MAX_IF_DEPTH];
    int if_top;

    int error_count;
} pp_context_t;
```

### Text buffer
```c
typedef struct {
    char *data;
    long len;
    long cap;
} buffer_t;
```
---

## 8. Module Responsibilities

### CLI (`src/cli`)
- Parses command-line arguments  
- Applies default behavior (`-c` if no flags)  
- Produces `cli_options_t`  
- Does not process files or text  

### IO (`src/io`)
- Reads files into `buffer_t`  
- Writes output buffers to files  
- Generates output filenames  

### PP_CORE (`src/pp_core`)
- Central preprocessing engine  
- Performs the single line-by-line pass  
- Calls Comments / Directives / Macros as needed  
- Tracks line numbers and context state  

### Comments (`src/comments`)
- Removes `//` and `/* */` comments  
- Replaces comments with spaces  
- Preserves all newline characters  
- Maintains state for multi-line block comments  

### Directives (`src/directives`)
Handles directive lines:
- `#include "file"`
- `#define`
- `#ifdef / #endif`  

Updates macro table and conditional state  
Directive lines do not produce normal output  

### Macros (`src/macros`)
- Expands macros in non-directive lines  
- Uses Tokens to replace only whole identifiers  
- Avoids expansion inside string literals  

### Tokens (`src/tokens`)
Lightweight tokenizer (P1 helper)  
Splits a line into:
- identifiers  
- string literals  
- separators  

Used by Directives and Macros  
Not the full lexer (P2)  

### Errors (`src/errors`)
- Reports errors with file name and line number  
- Increments global error count  
- Allows graceful error handling  

---

## 9. Comment Removal Semantics
- Both `//` and `/* */` comments are removed  
- Each removed comment is replaced by one space  
- All newline characters are preserved  
- Empty lines are not eliminated  

This guarantees correct line numbering.

---

## 10. Directive Semantics

### `#include "file"`
- Replaced by the full contents of file  
- Only local includes are supported  
- Included file contents are inserted into the output  

### `#define name value`
- Stored in the macro table  
- The directive line itself produces no output  

### `#ifdef name / #endif`
- Lines are conditionally included based on macro table  
- Nested conditionals are supported using a stack  

---

## 11. Development Rules
- No magic constants or strings (defined in `pp_spec.h`)  
- Functions should be short and focused  
- Each module exposes clear services  
- Project must always compile and run  
- Changes to core data structures must be discussed by the team  
- This README must be updated when interfaces change  

---

## 12. Team Responsibilities
Each team member owns one or more modules and is responsible for:
- design decisions  
- implementation  
- keeping this README consistent with the code  

---

## 13. Status
This README is a living document.  
It is refined as the project evolves and design decisions are finalized.
